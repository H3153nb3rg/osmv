package org.outlander.utils;

import org.outlander.io.db.CachedLocationsDatabaseHelper;
import org.outlander.model.LocationPoint;

import android.location.Location;
import android.util.Log;

/**
 * Broadcast receiver that will perform filtering algorithms on location
 * information that is received from the location service.
 * 
 * @author Adam Stroud &#60;<a
 *         href="mailto:adam.stroud@gmail.com">adam.stroud@gmail.com</a>&#62;
 */
public class FilteringLocationHelper {

    private static final String TAG                = "FilteringLocationHelper";
    private static final int    TIME_THRESHOLD     = 30000;                    // 30
                                                                                // sec.
    private static final int    ACCURACY_PERCENT   = 10;
    private static final int    VELOCITY_THRESHOLD = 200;                      // m/s

    public static boolean useLocation(final Location location) {
        boolean useLocation = false;

        final LocationPoint lastPoint = CachedLocationsDatabaseHelper.getInstance(null).retrieveLatestLocationPoint();
        if (lastPoint == null) {
            Log.d(TAG, "Adding point");
            useLocation = true;
        }
        else {

            // accept point if provider is same or
            // time trash
            useLocation = ((lastPoint.getProvider().equals(location.getProvider()) || ((location.getTime() - lastPoint.getTime()) > TIME_THRESHOLD)) || (lastPoint
                    .getAccuracy() > location.getAccuracy()));

            // float currentAccuracy = location.getAccuracy();
            // float previousAccuracy = lastPoint.getAccuracy();
            //
            //
            // // True IFF accuracy is greater, but limited to 10% of the
            // previous
            // // accuracy and new point was generated by the same provider
            // float accuracyDifference = Math.abs(previousAccuracy
            // - currentAccuracy);
            //
            // boolean lowerAccuracyAcceptable = currentAccuracy >
            // previousAccuracy
            // && lastPoint.getProvider().equals(location.getProvider())
            // && (accuracyDifference <= previousAccuracy
            // / ACCURACY_PERCENT);
            //
            // float[] results = new float[1];
            //
            // Location.distanceBetween(lastPoint.getLatitude(),
            // lastPoint.getLongitude(),
            // location.getLatitude(), location.getLongitude(), results);
            //
            // float velocity = results[0]
            // / ((location.getTime() - lastPoint.getTime()) / 1000);
            //
            // // Accept the new point if:
            // // * The velocity seems reasonable (point did not jump)and one of
            // // the
            // // following:
            // // * It has a better accuracy
            // // * The app has not accepted a point in TIME_THRESHOLD
            // // * It's worse accuracy is still acceptable
            // if (velocity <= VELOCITY_THRESHOLD
            // && (currentAccuracy < previousAccuracy
            // || (location.getTime() - lastPoint.getTime()) > TIME_THRESHOLD ||
            // lowerAccuracyAcceptable)) {
            // Ut.d( "Adding point");
            // useLocation = true;
            // } else {
            // Ut.d("Ignoring point");
            // }
        }

        return useLocation;
    }
}
